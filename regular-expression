正则指引
第一章
字符组
\d (digit) 等价于 [0-9]
\s (space) 等价于 [ \t\r\n\v\f]
\w (word) 等价于 [0-9a-zA-Z_]
\S \D \W 和 \s \d \w恰好相反，所以[\s\S] [\d\D] [\w\W] 可以匹配任意字符
. 能匹配任意字符，但不能匹配换行符'\n'

第二章
量词
—————————————————————————————————————————————————————————————
常用量词 | {m,n}等价形式  注：逗号后面没有空格
—————————————————————————————————————————————————————————————
   *     | {0,}
—————————————————————————————————————————————————————————————
   +     | {1,}
—————————————————————————————————————————————————————————————
   ?     | {0,1}
—————————————————————————————————————————————————————————————

匹配HTML tag,如<table> <img> <head> : <[^>]+>
/*
 对于<input name="text" value=">" /> 这样的字符串的匹配是有问题的
 > 只能作为属性出现， '[^']*' 和 "[^"]*"
 <('[^']*'|"[^"]*"|[^'">])+>  这样就好了
*/

open tag : <[^/>][^>]*>
close tag : </[^>]+>
self-closing tag : <[^>/]+/>
其实<[^/>][^>]*>也可以匹配 self-closing tag, <[^/>][^>]*[^/]> 就可以保证匹配的open tag不会以/>结尾了。但无法匹配如<u>这样的tag
使用分组解决这样一个问题: <[^/>]([^>]*[^/])?>   
贪婪匹配之优先匹配量词：
".*"  去匹配 "quoted string" and another" 得到 "quoted string and another",
"[^"]*" 匹配其得到 "quoted string"
贪婪匹配，一开始匹配全部，当把文本字符全部匹配完后，发现pattern还有式子没有匹配，查询之前保存的备用状态，如果发现有能匹配的，
就看能不能退回几步，这就是回溯。让.*"反悔"匹配，交给pattern后面的式子进行匹配。

忽略优先量词：
[\s\S]*
[\s\S]*?      忽略优先量词  *?和*限定的元素出现次数范围与*完全一样
遇到[\s\S]能匹配的字符，先尝试"忽略",如果pattern中后面的元素不能匹配，再尝试匹配。

忽略优先量词优先选择"忽略"，匹配优先量词会优先选择"匹配"。忽略优先量词必须兼顾它所限定的元素和之后的元素，效率会有一定的降低。
——————————————————————————————————————————————————————————————————————————
匹配优先量词  |  忽略优先量词 |   限定次数
——————————————————————————————————————————————————————————————————————————
     *        |       *?      | 可能出现，也可能不出现，出现次数没有上限 
——————————————————————————————————————————————————————————————————————————
     +        |       +?      | 至少出现一次，出现次数没有上限
——————————————————————————————————————————————————————————————————————————
     ?        |       ??      | 至多出现一次，也可能不出现 
——————————————————————————————————————————————————————————————————————————
   {m,n}      |      {m,n}?   | 出现次数最少为m次，最多为n次
——————————————————————————————————————————————————————————————————————————
   {m,}       |       {m,}?   | 出现次数最少为m次，没有上限
——————————————————————————————————————————————————————————————————————————
   {,n}       |       {,n}?   | 可能出现，也可能不出现，最多出现n次
——————————————————————————————————————————————————————————————————————————

匹配注释:
//.* 匹配   //xx
/\*[sS]*?\*/ 匹配 /**/ 
匹配超链接: <a\s[\s\S]+?</a>  (可以提取所有的超链接)

对于table tag:
匹配table: <table[\s>][\s\S]+?</table>
匹配tr: <tr[\s>][\s\S]+?</tr>

linux中匹配一个文件目录和文件： 如 /usr/local/bin/python
^.*/  匹配到 /usr/local/bin
[^/]*$ 匹配到python

如果需要匹配字符串{m,n}, 正则表达式需要写成\{m,n}

第三章
括号
匹配生份证：
15位身份证号码：[1-9]\d{14}
18位身份证号码：[1-9]\d{14}\d{2}[0-9x]
通用的匹配身份证号码：[1-9]\d{14}(\d{2}[0-9x])?   
量词限定之前元素的出现，这个元素可能是一个字符，也可能是一个字符组，还可能是一个表达式——如果把这个表达式用括号括起来，
这个元素就是括号里的表达式，括号内的表达式通常被称为"子表达式"。(\d{2}[0-9x])作为一个整体，或许不出现，或许最多出现一次。
括号的这种功能，叫做分组(grouping)

写一个正则匹配 
/foo
/foo/bar.php
/foo/bar_qux.php  这几种情况
/foo是必需出现的，之后存在呢两种可能，
——————————————————————————————————————————————————————————————————
/bar.php对应的表达式          |    /[a-z]+\.php
——————————————————————————————————————————————————————————————————
/bar_qux.php对应的表达式      |    /[a-z]+_[a-z]+\.php
——————————————————————————————————————————————————————————————————
上面两种情况合并之后的表达式  |    /[a-z]+(_[a-z]+)?\.php
——————————————————————————————————————————————————————————————————
和/foo合并                    |    /[a-z]+(/[a-z]+(_[a-z]+)?\.php)?
——————————————————————————————————————————————————————————————————
注意其写正则的思路

匹配邮箱：
ijiaobu@qq.com, 分为两段，用户名和主机名
\w就是[A-Za-z0-9_], 匹配用户名就是 [-.\w]{0,64} 最长为64个字符
主机名一般就是 somehost.net sub.somehost.net mail.sub.somehost.net
所以匹配规则就是 ([-a-zA-Z0-9]{1,63}\.)*[-a-zA-Z0-9]{1,63} 

多选结构匹配身份证号码：([1-9]\d{14}|[1-9]\d{16}[0-9x])      
匹配IP地址，对IP地址分析为0-255:
————————————————————————————————————————————————————————————————————————————
如果是 1 位数                                                  | [0-9]
————————————————————————————————————————————————————————————————————————————
如果是 2 位数                                                  | [0-9]{2}
————————————————————————————————————————————————————————————————————————————
如果是 3 位数                                                  |
————————————————————————————————————————————————————————————————————————————
    如果第1位是1                                               | 1[0-9][0-9]
————————————————————————————————————————————————————————————————————————————
    如果第1位是2                                               | 
————————————————————————————————————————————————————————————————————————————
        如果第2位是0~4                                         | 2[0-4][0-9]
————————————————————————————————————————————————————————————————————————————
        如果第2位是5                                           | 25[0-5]
————————————————————————————————————————————————————————————————————————————
用多选结构把这几个表达式合并起来，
([0-9]|[0-9]{2}|1[0-9][0-9]|2[0-4][0-9]|25[0-5])
识别030、005这样的数值
((00)?[0-9]|0?[0-9]{2}|1[0-9][0-9]|2[0-4][0-9]|25[0-5])

匹配年月日：
————————————————————————————————————————————————————————————————————————————
月                 |  (0?[1-9]|1[012])
————————————————————————————————————————————————————————————————————————————
日                 |  (0?[1-9]|[12][0-9]|3[01])
————————————————————————————————————————————————————————————————————————————
小时               |  (0?[1-9]|[01]\d|2[0-4])
————————————————————————————————————————————————————————————————————————————
分钟               |  (0?[1-9]|[0-5]\d|60)
————————————————————————————————————————————————————————————————————————————

匹配手机号：手机号一般11位，前三位是号段，目前有  130-139、 150-153、155-156、180、182、185-189
(13[0-9]|15[0-356]|18[025-9])\d{8}, 如果有0或+86,则：
(0|+86)?(13[0-9]|15[0-356]|18[025-9])\d{8}

注：^ab|cd$等价于(^ab|cd$)，表示以字符串ab开头或者字符串结尾的cd

匹配所有的url，捕获分组(capturing group)：
<a href="url">text</a>    url 是地址， text是文本
<a\s+href="([^"]+)">([^<]+)</a>

若等号两端可能有空白字符：
<a\s+href\s*=\s*"([^"]+)">([^<]+)</a>

属性可以<a href='url'>text</a> 或 <a href=url>text</a>   
首尾出现的单双引号可以用 ['"]? 表示， url不能包含单引号、双引号、空白字符 [^'"\s]+
<a\s+href\s*=\s*['"]?([^'"\s]+)['"]?>([^<]+)</a>
<img src之间可能还有其他内容，比如width=750,不能仅仅是 \s+ 的匹配，添加 [^>]*?
<a\s+[^>]*?href\s*=\s*['"]?([^'"\s]+)['"]?>([^<]+)</a>

反向引用(back-reference),它允许正则表达式内部引用之前的捕获分组匹配的文本(也就是左侧),其形式也是\num,
其中num是分组编号。根据反向引用，查找连续重叠字母的表达式就是 ([a-z])\1, 其中的[a-z]匹配第一个字母，
再用括号将匹配分组，然后用\1来反向引用
$pattern = '/^([a-z])\1$';
$string = 'aa';
preg_match($pattern, $string, $arr)  //true

用反向引用匹配成对的tag：
注意使用到的忽略优先量词 *? 
<([^>]+)>[\s\S]*?</\1>  

如果tag变得复杂一点: <span class="classname">text</span>，应用上面的情况就不能精确匹配出tag span 了
于是让分组1精确匹配tag name，可以是数字、小写字母、大写字母， 为了和上面的情况兼容，必须用括号分组和量词?来限定,改成 (\s[^>]+)?
<([a-zA-Z0-9]+)(\s[^>]+)?>[\s\S]*?</\1>

反向引用重复的是对应捕获分组匹配的文本，而不是之前的表达式;反向引用的是由之前表达式决定的具体文本，而不是符合某种规则的未知文本。

对于php中的引用的用法，\num 或者 $num,使用$num可以准确的匹配第几个分组，但最好是 \${num}($符号要转义), 如\${1}表示匹配第一个分组。
以消除$10会产生的二义性。

上面总共三个概念，介绍括号的三种用途：分组、多选结构、引用分组
对于引用分组，无论是否需要，只要出现了括号，正则表达式在匹配时就会把括号内的子表达式存储起来，提供引用。如果并不需要引用，
保存这些信息无疑会影响正则表达式的性能。为解决这个问题，正则表达式提供了非捕获分组(non-capturing group),分捕获分组类似
普通的捕获分组，只是在开括号后紧跟一个问号和冒号(?:),这样的括号叫做非捕获型括号，它只能限定量词的作用范围，不捕获任何文本。
如：
print re.search(r"(\d{4})-(\d{2})-(\d{2})", "2012-12-22").group(2)
12
print re.search(r"(?:\d{4})-(\d{2})-(\d{2})", "2012-12-22").group(1)   非捕获分组略过 
12
所以，如果只需要使用括号的分组或者多选结构的功能，而没有用到引用分组，则应当尽量使用分捕获型符号(?:)

转义：
* + ?   --->  \* \+ \? 
对于成队出现的元字符 {6} [a-z]   --->   \{6} \[a-z]
但括号的转义有所不同， (|)  --->  \(\|\)  三个都得转义

