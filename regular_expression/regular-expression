正则指引
第一章
字符组
\d (digit) 等价于 [0-9]
\s (space) 等价于 [ \t\r\n\v\f]
\w (word) 等价于 [0-9a-zA-Z_]
\S \D \W 和 \s \d \w恰好相反，所以[\s\S] [\d\D] [\w\W] 可以匹配任意字符
. 能匹配任意字符，但不能匹配换行符'\n'

第二章
量词
—————————————————————————————————————————————————————————————
常用量词 | {m,n}等价形式  注：逗号后面没有空格
—————————————————————————————————————————————————————————————
   *     | {0,}
—————————————————————————————————————————————————————————————
   +     | {1,}
—————————————————————————————————————————————————————————————
   ?     | {0,1}
—————————————————————————————————————————————————————————————

匹配HTML tag,如<table> <img> <head> : <[^>]+>
/*
 对于<input name="text" value=">" /> 这样的字符串的匹配是有问题的
 > 只能作为属性出现， '[^']*' 和 "[^"]*"
 <('[^']*'|"[^"]*"|[^'">])+>  这样就好了
*/

open tag : <[^/>][^>]*>
close tag : </[^>]+>
self-closing tag : <[^>/]+/>
其实<[^/>][^>]*>也可以匹配 self-closing tag, <[^/>][^>]*[^/]> 就可以保证匹配的open tag不会以/>结尾了。但无法匹配如<u>这样的tag
使用分组解决这样一个问题: <[^/>]([^>]*[^/])?>   
贪婪匹配之优先匹配量词：
".*"  去匹配 "quoted string" and another" 得到 "quoted string and another",
"[^"]*" 匹配其得到 "quoted string"
贪婪匹配，一开始匹配全部，当把文本字符全部匹配完后，发现pattern还有式子没有匹配，查询之前保存的备用状态，如果发现有能匹配的，
就看能不能退回几步，这就是回溯。让.*"反悔"匹配，交给pattern后面的式子进行匹配。

忽略优先量词：
[\s\S]*
[\s\S]*?      忽略优先量词  *?和*限定的元素出现次数范围与*完全一样
遇到[\s\S]能匹配的字符，先尝试"忽略",如果pattern中后面的元素不能匹配，再尝试匹配。

忽略优先量词优先选择"忽略"，匹配优先量词会优先选择"匹配"。忽略优先量词必须兼顾它所限定的元素和之后的元素，效率会有一定的降低。
——————————————————————————————————————————————————————————————————————————
匹配优先量词  |  忽略优先量词 |   限定次数
——————————————————————————————————————————————————————————————————————————
     *        |       *?      | 可能出现，也可能不出现，出现次数没有上限 
——————————————————————————————————————————————————————————————————————————
     +        |       +?      | 至少出现一次，出现次数没有上限
——————————————————————————————————————————————————————————————————————————
     ?        |       ??      | 至多出现一次，也可能不出现 
——————————————————————————————————————————————————————————————————————————
   {m,n}      |      {m,n}?   | 出现次数最少为m次，最多为n次
——————————————————————————————————————————————————————————————————————————
   {m,}       |       {m,}?   | 出现次数最少为m次，没有上限
——————————————————————————————————————————————————————————————————————————
   {,n}       |       {,n}?   | 可能出现，也可能不出现，最多出现n次
——————————————————————————————————————————————————————————————————————————

匹配注释:
//.* 匹配   //xx
/\*[sS]*?\*/ 匹配 /**/ 
匹配超链接: <a\s[\s\S]+?</a>  (可以提取所有的超链接)

对于table tag:
匹配table: <table[\s>][\s\S]+?</table>
匹配tr: <tr[\s>][\s\S]+?</tr>

linux中匹配一个文件目录和文件： 如 /usr/local/bin/python
^.*/  匹配到 /usr/local/bin
[^/]*$ 匹配到python

如果需要匹配字符串{m,n}, 正则表达式需要写成\{m,n}

第三章
括号
匹配生份证：
15位身份证号码：[1-9]\d{14}
18位身份证号码：[1-9]\d{14}\d{2}[0-9x]
通用的匹配身份证号码：[1-9]\d{14}(\d{2}[0-9x])?   
量词限定之前元素的出现，这个元素可能是一个字符，也可能是一个字符组，还可能是一个表达式——如果把这个表达式用括号括起来，
这个元素就是括号里的表达式，括号内的表达式通常被称为"子表达式"。(\d{2}[0-9x])作为一个整体，或许不出现，或许最多出现一次。
括号的这种功能，叫做分组(grouping)

写一个正则匹配 
/foo
/foo/bar.php
/foo/bar_qux.php  这几种情况
/foo是必需出现的，之后存在呢两种可能，
——————————————————————————————————————————————————————————————————
/bar.php对应的表达式          |    /[a-z]+\.php
——————————————————————————————————————————————————————————————————
/bar_qux.php对应的表达式      |    /[a-z]+_[a-z]+\.php
——————————————————————————————————————————————————————————————————
上面两种情况合并之后的表达式  |    /[a-z]+(_[a-z]+)?\.php
——————————————————————————————————————————————————————————————————
和/foo合并                    |    /[a-z]+(/[a-z]+(_[a-z]+)?\.php)?
——————————————————————————————————————————————————————————————————
注意其写正则的思路

匹配邮箱：
ijiaobu@qq.com, 分为两段，用户名和主机名
\w就是[A-Za-z0-9_], 匹配用户名就是 [-.\w]{0,64} 最长为64个字符
主机名一般就是 somehost.net sub.somehost.net mail.sub.somehost.net
所以匹配规则就是 ([-a-zA-Z0-9]{1,63}\.)*[-a-zA-Z0-9]{1,63} 

多选结构匹配身份证号码：([1-9]\d{14}|[1-9]\d{16}[0-9x])      
匹配IP地址，对IP地址分析为0-255:
————————————————————————————————————————————————————————————————————————————
如果是 1 位数                                                  | [0-9]
————————————————————————————————————————————————————————————————————————————
如果是 2 位数                                                  | [0-9]{2}
————————————————————————————————————————————————————————————————————————————
如果是 3 位数                                                  |
————————————————————————————————————————————————————————————————————————————
    如果第1位是1                                               | 1[0-9][0-9]
————————————————————————————————————————————————————————————————————————————
    如果第1位是2                                               | 
————————————————————————————————————————————————————————————————————————————
        如果第2位是0~4                                         | 2[0-4][0-9]
————————————————————————————————————————————————————————————————————————————
        如果第2位是5                                           | 25[0-5]
————————————————————————————————————————————————————————————————————————————
用多选结构把这几个表达式合并起来，
([0-9]|[0-9]{2}|1[0-9][0-9]|2[0-4][0-9]|25[0-5])
识别030、005这样的数值
((00)?[0-9]|0?[0-9]{2}|1[0-9][0-9]|2[0-4][0-9]|25[0-5])

匹配年月日：
————————————————————————————————————————————————————————————————————————————
月                 |  (0?[1-9]|1[012])
————————————————————————————————————————————————————————————————————————————
日                 |  (0?[1-9]|[12][0-9]|3[01])
————————————————————————————————————————————————————————————————————————————
小时               |  (0?[1-9]|[01]\d|2[0-4])
————————————————————————————————————————————————————————————————————————————
分钟               |  (0?[1-9]|[0-5]\d|60)
————————————————————————————————————————————————————————————————————————————

匹配手机号：手机号一般11位，前三位是号段，目前有  130-139、 150-153、155-156、180、182、185-189
(13[0-9]|15[0-356]|18[025-9])\d{8}, 如果有0或+86,则：
(0|+86)?(13[0-9]|15[0-356]|18[025-9])\d{8}

注：^ab|cd$等价于(^ab|cd$)，表示以字符串ab开头或者字符串结尾的cd

匹配所有的url，捕获分组(capturing group)：
<a href="url">text</a>    url 是地址， text是文本
<a\s+href="([^"]+)">([^<]+)</a>

若等号两端可能有空白字符：
<a\s+href\s*=\s*"([^"]+)">([^<]+)</a>

属性可以<a href='url'>text</a> 或 <a href=url>text</a>   
首尾出现的单双引号可以用 ['"]? 表示， url不能包含单引号、双引号、空白字符 [^'"\s]+
<a\s+href\s*=\s*['"]?([^'"\s]+)['"]?>([^<]+)</a>
<img src之间可能还有其他内容，比如width=750,不能仅仅是 \s+ 的匹配，添加 [^>]*?
<img\s+[^>]*?src\s*=\s*['"]?([^'"\s]+)['"]?[^>]*>

反向引用(back-reference),它允许正则表达式内部引用之前的捕获分组匹配的文本(也就是左侧),其形式也是\num,
其中num是分组编号。根据反向引用，查找连续重叠字母的表达式就是 ([a-z])\1, 其中的[a-z]匹配第一个字母，
再用括号将匹配分组，然后用\1来反向引用
$pattern = '/^([a-z])\1$';
$string = 'aa';
preg_match($pattern, $string, $arr)  //true

用反向引用匹配成对的tag：
注意使用到的忽略优先量词 *? 
<([^>]+)>[\s\S]*?</\1>  

如果tag变得复杂一点: <span class="classname">text</span>，应用上面的情况就不能精确匹配出tag span 了
于是让分组1精确匹配tag name，可以是数字、小写字母、大写字母， 为了和上面的情况兼容，必须用括号分组和量词?来限定,改成 (\s[^>]+)?
<([a-zA-Z0-9]+)(\s[^>]+)?>[\s\S]*?</\1>

反向引用重复的是对应捕获分组匹配的文本，而不是之前的表达式;反向引用的是由之前表达式决定的具体文本，而不是符合某种规则的未知文本。

对于php中的引用的用法，\num 或者 $num,使用$num可以准确的匹配第几个分组，但最好是 \${num}($符号要转义), 如\${1}表示匹配第一个分组。
以消除$10会产生的二义性。

上面总共三个概念，介绍括号的三种用途：分组、多选结构、引用分组
对于引用分组，无论是否需要，只要出现了括号，正则表达式在匹配时就会把括号内的子表达式存储起来，提供引用。如果并不需要引用，
保存这些信息无疑会影响正则表达式的性能。为解决这个问题，正则表达式提供了非捕获分组(non-capturing group),分捕获分组类似
普通的捕获分组，只是在开括号后紧跟一个问号和冒号(?:),这样的括号叫做非捕获型括号，它只能限定量词的作用范围，不捕获任何文本。
如：
print re.search(r"(\d{4})-(\d{2})-(\d{2})", "2012-12-22").group(2)
12
print re.search(r"(?:\d{4})-(\d{2})-(\d{2})", "2012-12-22").group(1)   非捕获分组略过 
12
所以，如果只需要使用括号的分组或者多选结构的功能，而没有用到引用分组，则应当尽量使用分捕获型符号(?:)

转义：
* + ?   --->  \* \+ \? 
对于成队出现的元字符 {6} [a-z]   --->   \{6} \[a-z]
但括号的转义有所不同， (|)  --->  \(\|\)  三个都得转义

为了避免分组影响效率，如果不需要提取捕获文本，应该把普通的括号(...)改为非捕获型括号(?:...)


                                                                第四章
                                                                 断言
有些结构并不是真正的匹配文本，而只负责判断在某个位置左/右侧的文本是否符合要求，这种结构被称为断言(assertion).
常见的断言有三类：单词边界、行起始/结束位置、环视。
单词边界(world boundary)：\b
\b能够匹配的位置：一边是单词字符，另一边不是单词字符。它匹配的是某个位置，而不是文本。
——————————————————————————————————————————————————————————————————————————————————————————
字符串       |       \brow\b     |    \brow       |           row\b        
——————————————————————————————————————————————————————————————————————————————————————————
tomorrow     |                   |                |            yes 
——————————————————————————————————————————————————————————————————————————————————————————
brown        |                   |                |                
——————————————————————————————————————————————————————————————————————————————————————————
row          |         yes       |     yes        |            yes    
——————————————————————————————————————————————————————————————————————————————————————————
rowdy        |                   |     yes        |                
——————————————————————————————————————————————————————————————————————————————————————————
表达式说明   |  只能是单词row    | \b的右侧是单词 |     \b的左侧是单词            
             |                   | 字符，所以左侧 |     字符，所以右侧
             |                   | 不能是单词字符 |     不能是单词字符
——————————————————————————————————————————————————————————————————————————————————————————
单词字符的要求"另一边不是单词字符"，不是"另一边的字符不是单词字符".所以字符串只是一个 word, \bword\b也是能匹配的
"单词字符"的解释是\w能匹配的字符。\w只能匹配 [0-9a-zA-Z_], 所以\b\w\b能准确的匹配英文单词。可以用 \b\w+\b 将所有
的单词提取出来。
但也有些单词是 \bw+\b无能为力的，比如 e-mail和M.I.T, 因为连字符-和点号.都不能由\w匹配的。也可以把表达式改成
\b[-\w]+\b

行起始/结束位置
^some   验证字符串是否以some开头 
在某些情况下，^ 也可以匹配字符串内部的"行起始位置"。匹配行终止符之后的位置，在编辑文本时，敲回车就输入"行终止符"(Line terminal),结束当前行，
新起一行。
————————————————————————————————————————————————————
平台       |        行终止符
————————————————————————————————————————————————————
unix/linux |          \n
————————————————————————————————————————————————————
windows    |         \r\n
————————————————————————————————————————————————————
Mac OS     |          \n
————————————————————————————————————————————————————
如果把匹配模式设定为 多行模式 (multiline mode),这是一种影响元字符匹配的设定， ^就既可以匹配整个字符串的起始位置，
也可以匹配换行符之后的位置，设定多行模式最简单的办法就是在正则表达式之前加上 (?m) ,这里的括号是指定匹配模式，所
以不会作为捕获分组。
提取每行的首字母单词   (?m)^\w+  
如果不想定位到字符串内部的行起始位置，只关心字符串的起始位置，则可以使用\A

$ 
一行"结束的位置"可能没有任何字符，然后就是终止符，终止符可能是\n \r\n
通常它匹配的是整个字符串的结尾位置————如果最后是行终止符，则匹配行终止符之前的位置;否则匹配最后一个字符之后的位置。
开启多行模式匹配，匹配没一行的最后一个单词: (?m)\w+$
与 $ 类似的还有两个特殊的标记 \Z和\z,他们不受多行模式的影响，在任何情况下都匹配整个字符串的结束位置。\Z和\z的主要差别为:
\Z等价于默认模式(非多行模式)下的$, 如果字符串的末尾有行终止符，则它匹配换行符之前的位置;\z则不管行终止符，只匹配"整个字符串的结束位置"

对于输入框 密码和邮箱的验证，一般来说 输入框中都不能输入换行符，但如果用户使用程序来提交就不一定了。
$ 可以匹配 "结尾行终止符之前的位置"，验证时就忽略了末尾的行终止符。
\A\d{6}\z     验证6位数字字符串

javascript 中只有^和$, 其中$只能匹配字符串/行的结束位置
/^a$/.test("a\n");        //False
/^a$/.test("a");   //True

环视：
匹配open tag: <[^/]([^>]*[^/])?>
一个像匹配 <html> 这样的open tag，
在开始位置匹配 <, 同时要求这个 < 之后不能是 / ;然后匹配中间文本，除非在属性(也就是引号字符串)中，否则不出现 > ,且长度必须大于1
(<>不是合法的tag); 最后匹配 > , 同时要求这个 > 之前不能是 / 。
单独来看，开头的 < 、中间的内容 、结尾的 > 

环视(look-around), 用来"停在原地，四处张望"。环视类似单词边界，在它旁边的文本需要满足某种条件，而且本身不匹配任何字符。
比如 <(?!/),其中的(?!/)是一个环视结构，(?!...)是这个结构的标识， / 才是真正的表达式，整个结构的意思是
"当前位置之后(右侧)，不容许出现 / 能匹配的文本"。和<[^/]类似，但大不一样：如果<(?!/)匹配成功，正则表达式真正匹配完成的只有 < ,
而不包括 < 之后的字符。这样就能准确表示 "匹配 < , 同时这个 < 之后不能是 / "。

再来看表达式 (?<!/)> ,其中的 (?<!/) 也是一个环视结构，(?<!...)是这个结构的标识， / 才是真正的表达式
整个结构的意思是"在当前位置之前(左侧)，不允许出现 / 能匹配的文本"。这样就能准确的表示"匹配 > ,同时 > 之前不能是 / "

('[^']*'|"[^"]*"|[^'">])+ 匹配open tag中间的内容
<(?!/)('[^']*'|"[^"]*"|[^'">])+(?<!/)> 就可以准确匹配 open tag 
总的来说，环视一共b分为四种：
——————————————————————————————————————————————————————————————————————————————————————————————————————————————
           名字                   |   记法     |        判断方向      |  结构内表达式匹配成功的返回值
——————————————————————————————————————————————————————————————————————————————————————————————————————————————
肯定顺序环视(positive-lookahead)  |  (?=...)   |          向右        | True
——————————————————————————————————————————————————————————————————————————————————————————————————————————————
否定顺序环视(negative-lookahead)  |  (?!...)   |          向右        | False
——————————————————————————————————————————————————————————————————————————————————————————————————————————————
肯定逆序环视(positive-lookbehind) |  (?<=...)  |          向左        | True
——————————————————————————————————————————————————————————————————————————————————————————————————————————————
否定逆序环视(nagative-lookbehind) |  (?<!...)  |          向左        | False
——————————————————————————————————————————————————————————————————————————————————————————————————————————————
朝右判断是顺序环视，朝左是逆序环视;要求表达式能匹配的字符串必须出现，则为肯定环视，否则为否定环视。
"原地"的判断，寻找的只是位置，而不需要真正匹配任何字符。

echo preg_replace('/(?=(\d{3})+)/', ',', '12345');     ,1,2,345

"右侧不能有数字字符"
echo preg_replace('/(?=(\d{3})+(?!\d))/', ',', '123456');     ,123,456

"左侧是数字字符"
echo preg_replace('/(?<=\d)(?=(\d{3})+(?!\d))/', ',', '12345');     123,456

使用环视，前面邮箱匹配中更准确的主机名验证：
常用的表达式： ([-a-zA-Z0-9]{1,63}\.)*[-a-zA-Z0-9]{1,63} 
这有两个问题：1、它容许域名字段的第一个字符是横线; 2、没有限定整个主机名的长度是255个字符
[-a-zA-Z0-9]{1,63}\. 改写为 (?!-)[-a-zA-Z0-9]{1,63}\.
准确匹配匹配主机名的表达式就是:
(?=[-a-zA-Z0-9.]{0,255}(?![-a-zA-Z0-9.])) ((?!-)[-a-zA-Z0-9]{1,63}\.)*((?!-)[-a-zA-Z0-9]){1,63}

匹配6位数字，比如邮政编码：
(?<!\d)\d{6}(?!\d)  

匹配辅音字母：(?![aeiou])[a-z]    [a-z]真正匹配一个小写字母

环视匹配的并不是字符，而是位置。在正则表达式匹配时，环视结构匹配成功，并不会更改"当前位置",所以多个环视可以组合在一起，
实现在同一个位置的多重判断。

环视包含环视
比如在前面的主机名的匹配中，
(?=[-a-zA-Z0-9.]{0,255}(?![-a-zA-Z0-9.])),
(?![-a-zA-Z0-9.]))包含在外层的环视中，它要求这个位置(也就是主机名字符串之后)不能出现属于主机名字符串的字符

并列多个环视
它要求在当前位置，所有的环视的判断都必须成功。
(?=\d+)(?!999)   要求在当前位置。之后必须出现数字字符串;在当前位置，之后不能是999

环视作为多选分支排列在多选结构中
((?!\d) | (?=\d\D)) 表示它之后要么是数字字符，要么是一个数字字符和一个非数字字符
只要有一个成立，整个判断就成功。

反向引用时，之前捕获分组的断言都会被忽略，
比如说匹配重复单词正确的写法：
(\b\w+\b).*?\b\1\b
而不是(\b\w+\b).*?\1

----------------------------------------------------------------------------------------------------------------------------
                                                第五章      匹配模式(match mode)
不区分大小写模式(case-insensitive):
php中的写法: /regex/i
不区分大小写模式：
匹配超链接     (?i)<a\s+[^>]*?href\s*=\s*['"]?([^'"\s]+)['"]?>([^<]+)</a>
提取标题       (?i)<head>([^>]+)</head> 
匹配图片       (?i)<img\s+[^>]*?src\s*=\s*['"]?([^'"\s]+)['"]?[^>]*>
--------------------------------------------------------------------------------------------

单行模式(single line):
比如说匹配javascript代码：
<script\s[\s\S]*?</script>  改成单行模式:  (?s)<script\s.*?</script>
在这种模式下，所有文本似乎只在一行里，换行符是这一行中的"普通字符", 所以可以由点号 . 匹配
php的写法: /regex/s
javascript 不支持这种写法
--------------------------------------------------------------------------------------------

多行模式(Multiline):
单行模式影响的是点号的匹配规则：默认情况下，点号 . 可以匹配除换行符之外的任何字符，在单行模式下，点 . 号可以匹配包括换行符在内的任何
字符;多行模式影响的是^和$的匹配规则:在默认模式下，^和$匹配的是整个字符串的起始位置和结束位置，但在多行模式下，他们也能匹配字符串内部
某一行文本的起始位置和结束位置。

找到下面文本中所有数字字符开头的行。
1 line 
no digit
2 line
写出的正则是 (?m)^\d.*  
js和php: /regex/m
--------------------------------------------------------------------------------------------

注释模式(extended mode):
((?x)(\d{4})-(\d{2})-(\d{2})), 应用注释模式则像下面这样展开:

pattern = '/
(         #start of whole regex
    (\d{4})   #year
    -         #dash
    (\d{2})   #month
    -         #dash
    (\d{2})   #day
)/x';
$string = '2014-12-25';
if (preg_match($pattern, $string, $arr))
{
    echo '<pre>';
    print_r($arr);
    echo '</pre>';
}
--------------------------------------------------------------------------------------------

失效修饰符 (?i)(foo|zee)(?-i)BAR
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
                                        第六章      其他
通常说的string(字符串)中, string称为字符串文字(string literal), 它是某个字符串的值在源代码中的表现形式。
比如字符串文字\n,它包含 \ 和 n 两个字符，意义(即它的值)是一个换行符(为方便观察，表示为[NL] )
在生成字符串时需要进行"字符串转义"。

字符串文字————>字符串/正则文字————>正则表达式
——————————————————————————————————————————————————————————————————
字符串文字    |   字符串/正则文字     | 正则表达式  |  说明
——————————————————————————————————————————————————————————————————
\\n           |       \n              |    [NL]     | 换行符
——————————————————————————————————————————————————————————————————
\\t           |       \t              |    [TAB]    | 指标符
——————————————————————————————————————————————————————————————————
\\\\          |       \\              |      \      |反斜线字符
——————————————————————————————————————————————————————————————————

re.search("\\\\", "\\") != None   #   => True

注意: \b 在一般字符串中 \b是预定义的转义序列，表示退格符(backspace, 表示为[BS])
      但是在正则表达式中，他表示单词边界(记为[\B])
——————————————————————————————————————————————————————————————————————
字符串文字   |  字符串/正则文字 | 正则表达式 |   说明
——————————————————————————————————————————————————————————————————————
\b           |      [BS]        |  [BS]      |  退格符
——————————————————————————————————————————————————————————————————————
\\b          |       \b         |  [\B]      | 单词边界
——————————————————————————————————————————————————————————————————————
re.search("\ba\b", "a") != None  # => False
re.search("\\ba\\b", "a") != None # => True
re.search(r"\ba\b", "a") != None # => True   原生字符串

对于\d \w \s 都不是合法的转义序列，但python和php不会报编译错误，这是因为他们对字符串有特殊规定：
如果遇到无法识别的转义序列，则将它原封不动的保存下来。
所以\d \w \s 效果与 \\d \\w \\s是一样的

彻底消除元字符的特殊含义(php和java明确支持): 加 \Q(quote) \E(end)
/\Qca*t\E/
preg_quote()

子符组中的转义 [0\-9] [\^ab] [0\]9]

正则表达式并不等于字符串，即便正则表达式是以字符串形式给出的，进行正则表达式操作之前，必须首先生成专用的"正则表达式对象"。

